/*
 * key_value.c
 *
 *  Created on: Mar 4, 2017
 *      Author: ArnoldK
 */


#include "read_eval.h"

#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>

//UNCOMMENT To debug
//#define DEBUG



//Hash function provided by the professor
int hash_func(char *word){
	int hashAddress = 5381;
	for (int counter = 0; word[counter]!='\0'; counter++){
		hashAddress = ((hashAddress << 5) + hashAddress) + word[counter];
	}
	return hashAddress % POD_NUMBER_LIMIT < 0 ? -hashAddress % POD_NUMBER_LIMIT : hashAddress % POD_NUMBER_LIMIT;
}


int  kv_store_create(const char *name){

	//Input validation
	if (name == NULL){
		printf("Please enter a valid database name...\n");
		return -1;
	}

	//Create or Open shared memory slot
	int fd = shm_open(name, O_CREAT|O_RDWR, S_IRWXU);

	//If unsuccessful, prevent the caller
	if (fd == -1){
		printf("Could not create shared memory\n");
		return -1;
	}

	//Copy the name of the database to a global variable to save it for the whole session
	db_name = strdup(name);

	/* Size of the shared memory =
	 * Size of node (a pod contains X number of nodes) * Number of nodes in a pod * Number of pods
	 * + Size of the array index for the pods
	 */
	size_t length = sizeof(struct node) * POD_SIZE * POD_NUMBER_LIMIT + sizeof(int) * POD_NUMBER_LIMIT;

#ifdef DEBUG
	printf("Size of memory shared(create): %d\n", (int)length);
#endif

	//Resize the shared memory which the max length of our key_value hashmap
	ftruncate(fd, length);

	char *mem_addr = mmap(NULL, length, PROT_WRITE, MAP_SHARED, fd, 0);
	close(fd);

	//Put the index pod array at the end of the shared memory
	int pod_index[POD_NUMBER_LIMIT];
	memcpy(pod_index , mem_addr + sizeof(struct node) * POD_SIZE * POD_NUMBER_LIMIT, sizeof(int) * POD_NUMBER_LIMIT);

	//If the store is newly created, initiate the index pod array padded with 0's at the end of the shared memory
	if(pod_index == NULL){
		int *pod_index = calloc(POD_NUMBER_LIMIT, sizeof(int));
		memcpy(mem_addr + sizeof(struct node) * POD_SIZE * POD_NUMBER_LIMIT, pod_index , sizeof(int) * POD_NUMBER_LIMIT);
		free(pod_index);
	}

	return 0;
}


int  kv_store_write(const char *key, const char *value){

	//Input validation
	if (key == NULL || value == NULL){
		printf("Please enter a valid key and value...\n");
		return -1;
	}

	//Open shared memory slot
	int fd = shm_open(db_name, O_RDWR, S_IRWXU);
	//If unsuccessful, prevent the caller
	if (fd == -1){
		printf("Could not open shared memory\n");
		return -1;
	}

	//Get size of the shared memory
	struct stat s;
	if(fstat(fd, &s) == -1){
		printf("Could not determine length of the shared memory\n");
		return -1;
	}

#ifdef DEBUG
	printf("Size of memory shared(write): %d\n", (int)s.st_size);
#endif

	//Map this new memory address to a base address generated by the os
	char *mem_addr = mmap(NULL, s.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	close(fd);

	//Create the new element and generate its hashmap key
	struct node *new_node = malloc(sizeof(struct node));

	//Copy the key and value to the node and truncate if necessary
	strncpy(new_node->key, key, sizeof(new_node->key));
	strncpy(new_node->value,value, sizeof(new_node->value));
	new_node->key[KEY_MAX_LENGTH-1] = '\0';
	new_node->value[VALUE_MAX_LENGTH-1] = '\0';

	//Show new result if truncated
	if (strlen(key) > KEY_MAX_LENGTH-1){
		printf("Key too big, Truncated key is: %s\n", new_node->key);
	}
	if (strlen(value) > VALUE_MAX_LENGTH-1){
		printf("Value too big, it will be truncated\n");
		//printf("Value too big, Truncated value is: %s\n", new_node->value);
	}

	int hashkey = hash_func(new_node->key);

	//Find the size of the current pod to know where to write the new element
	int pod_index[POD_NUMBER_LIMIT];
	memcpy(pod_index, mem_addr + sizeof(struct node) * POD_SIZE * POD_NUMBER_LIMIT, sizeof(pod_index));


	//Put the element in the shared memory using its hashmap key and the index of its new position
	//(add it to the memory address of the shared memory)
	memcpy(mem_addr + hashkey*POD_SIZE + pod_index[hashkey]*sizeof(struct node), new_node, sizeof(struct node));
	free(new_node);

	//Update the index array of the pods (to track the number of elements into each pod) and copy array to memory
	pod_index[hashkey]++;
	memcpy(mem_addr + sizeof(struct node) * POD_SIZE * POD_NUMBER_LIMIT, pod_index, sizeof(pod_index));

	return 0;
}


char *kv_store_read(const char *key){

	//Input validation
	if (key == NULL){
		printf("Please enter a valid key...\n");
		return 0;
	}

	//Open shared memory slot
	int fd = shm_open(db_name, O_RDWR, S_IRWXU);
	//If unsuccessful, prevent the caller
	if (fd == -1){
		printf("Could not open shared memory\n");
		return 0;
	}

	//Get size of the shared memory
	struct stat s;
	if(fstat(fd, &s) == -1){
		printf("Could not determine length of the shared memory\n");
		return 0;
	}

#ifdef DEBUG
	printf("Size of memory shared(read): %d\n", (int)s.st_size);
#endif

	//Map this new memory address to a base address generated by the os
	char *mem_addr = mmap(NULL, s.st_size, PROT_READ, MAP_SHARED, fd, 0);
	close(fd);

	//Reproduce key and make sure it is right size
	char normalizedKey[KEY_MAX_LENGTH];
	strncpy(normalizedKey, key, KEY_MAX_LENGTH);
	normalizedKey[KEY_MAX_LENGTH-1] = '\0';

	//Show new result if truncated
	if (strlen(key) > KEY_MAX_LENGTH-1){
		printf("Key too big, Truncated key is: %s\n", normalizedKey);
	}

	//Reconstruct the element from the hashmap using the key
	int hashkey = hash_func(normalizedKey);

	//Create a pod index to limit the number of searches in the end for large number of elements in a pod
	int pod_index[POD_NUMBER_LIMIT];
	memcpy(pod_index, mem_addr + sizeof(struct node) * POD_SIZE * POD_NUMBER_LIMIT, sizeof(pod_index));


	//If the size the pod is 0 then the key does not exist
	if(pod_index[hashkey] == 0){
		return 0;
	}

	//Find the index of the correct value to read (FIFO). If no value from that key was yet read, take the first one encountered
	int read_index;
	for (int i = 0; i < pod_index[hashkey]; i++){
		if (read_array[i]->index == -1) {
			strcpy(read_array[i]->key, normalizedKey);
			read_array[i]->index = 0;
			read_index = 0;
			break;
		}

		if(!strcmp(read_array[i]->key, normalizedKey)){

			read_array[i]->index++;
			read_index = read_array[i]->index;
		}
	}

	//Count each corresponding key until the count is equal to the index we previously created
	struct node *new_node = malloc(sizeof(struct node));
	int count = -1;
	for(int i = 0; i < pod_index[hashkey]; i++){
		memcpy(new_node, mem_addr + hashkey*POD_SIZE + i*sizeof(struct node), sizeof(struct node));
		if(!strcmp(new_node->key, normalizedKey)){
			count++;
			if(count == read_index){
				break;
			}
		}
	}

	//If we did not find the right key, return nothing found
	if(strcmp(new_node->key, normalizedKey)){
		free(new_node);
		return 0;
	}

	//Copy the value to a new char array to free that variable in the caller
	char *value = strdup(new_node->value);
	free(new_node);

	return value;
}

char **kv_store_read_all(const char *key){

	return 0;
}
