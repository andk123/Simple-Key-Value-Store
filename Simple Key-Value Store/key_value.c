/*
 * key_value.c
 *
 *  Created on: Mar 4, 2017
 *      Author: ArnoldK
 */


#include "read_eval.h"

#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>

//UNCOMMENT To debug
//#define DEBUG


//Hash function provided by the professor
int hash_func(char *word){
	int hashAddress = 5381;
	for (int counter = 0; word[counter]!='\0'; counter++){
		hashAddress = ((hashAddress << 5) + hashAddress) + word[counter];
	}
	return hashAddress % POD_NUMBER_LIMIT < 0 ? -hashAddress % POD_NUMBER_LIMIT : hashAddress % POD_NUMBER_LIMIT;
}

void moveMemory(char *mem_addr){

	//We know the pod is full so there is POD_SIZE number of key_value pairs in the current pod

	//Swap every element on the array except the first one (which will be deleted) to free the last spot
	//This operation is costly but we have to do so to the prevent the case where the key_value is not in the array already
	//and at the same time to respect the FIFO order.
	for(int j = 1; j < POD_SIZE; j++){
		memcpy(mem_addr + (j-1)*sizeof(struct node), mem_addr + j*sizeof(struct node), sizeof(struct node));
	}

}


int  kv_store_create(const char *name){

	//Input validation
	if (name == NULL){
		printf("Please enter a valid database name...\n");
		return -1;
	}

	//Create or Open shared memory slot
	int fd = shm_open(name, O_CREAT|O_RDWR, S_IRWXU);

	//If unsuccessful, prevent the caller
	if (fd == -1){
		printf("Could not create shared memory\n");
		return -1;
	}

	//Copy the name of the database to a global variable to save it for the whole session
	db_name = strdup(name);

	/* Size of the shared memory =
	 * Size of node (a pod contains X number of nodes) * Number of nodes in a pod * Number of pods
	 * + Size of the array index for the pods
	 */
	size_t length = sizeof(struct node) * POD_SIZE * POD_NUMBER_LIMIT + sizeof(int) * POD_NUMBER_LIMIT;

#ifdef DEBUG
	printf("Size of memory shared(create): %d\n", (int)length);
#endif

	//Resize the shared memory which the max length of our key_value hashmap
	ftruncate(fd, length);

	char *mem_addr = mmap(NULL, length, PROT_WRITE, MAP_SHARED, fd, 0);
	close(fd);

	//Put the index pod array at the end of the shared memory
	int pod_index[POD_NUMBER_LIMIT];
	memcpy(pod_index , mem_addr + sizeof(struct node) * POD_SIZE * POD_NUMBER_LIMIT, sizeof(int) * POD_NUMBER_LIMIT);

	//If the store is newly created, initiate the index pod array padded with 0's at the end of the shared memory
	if(pod_index == NULL){
		int *pod_index = calloc(POD_NUMBER_LIMIT, sizeof(int));
		memcpy(mem_addr + sizeof(struct node) * POD_SIZE * POD_NUMBER_LIMIT, pod_index , sizeof(int) * POD_NUMBER_LIMIT);
		free(pod_index);
	}

	munmap(mem_addr, length);

	return 0;
}


int  kv_store_write(const char *key, const char *value){

	//Input validation
	if (key == NULL || value == NULL){
		printf("Please enter a valid key and value...\n");
		return -1;
	}

	//Open shared memory slot
	int fd = shm_open(db_name, O_RDWR, S_IRWXU);
	//If unsuccessful, prevent the caller
	if (fd == -1){
		printf("Could not open shared memory\n");
		return -1;
	}

	//Get size of the shared memory
	struct stat s;
	if(fstat(fd, &s) == -1){
		printf("Could not determine length of the shared memory\n");
		return -1;
	}

#ifdef DEBUG
	printf("Size of memory shared(write): %d\n", (int)s.st_size);
#endif

	//Map this new memory address to a base address generated by the os
	char *mem_addr = mmap(NULL, s.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	close(fd);

	//Create the new element and generate its hashmap key
	struct node *new_node = malloc(sizeof(struct node));

	//Copy the key and value to the node and truncate if necessary
	strncpy(new_node->key, key, sizeof(new_node->key));
	strncpy(new_node->value,value, sizeof(new_node->value));
	new_node->key[KEY_MAX_LENGTH-1] = '\0';
	new_node->value[VALUE_MAX_LENGTH-1] = '\0';

	//Show new result if truncated
	if (strlen(key) > KEY_MAX_LENGTH-1){
		printf("Key too big, Truncated key is: %s\n", new_node->key);
	}
	if (strlen(value) > VALUE_MAX_LENGTH-1){
		printf("Value too big, it will be truncated\n");
		//printf("Value too big, Truncated value is: %s\n", new_node->value);
	}

	int hashkey = hash_func(new_node->key);

	//Find the size of the current pod to know where to write the new element
	int pod_index[POD_NUMBER_LIMIT];
	memcpy(pod_index, mem_addr + sizeof(struct node) * POD_SIZE * POD_NUMBER_LIMIT, sizeof(pod_index));


	//If the pod is full delete the first key_value swap all the others -1 position
	if (pod_index[hashkey] == POD_SIZE){
		moveMemory(mem_addr + hashkey*POD_SIZE);
		pod_index[hashkey]--;
	}

	//Put the element in the shared memory using its hashmap key and the index of its new position
	//(add it to the memory address of the shared memory)
	memcpy(mem_addr + hashkey*POD_SIZE + pod_index[hashkey]*sizeof(struct node), new_node, sizeof(struct node));
	free(new_node);

	//Update the index array of the pods (to track the number of elements into each pod) and copy array to memory
	pod_index[hashkey]++;
	memcpy(mem_addr + sizeof(struct node) * POD_SIZE * POD_NUMBER_LIMIT, pod_index, sizeof(pod_index));
	printf("Numbers in store: %d\n", pod_index[hashkey]);
	munmap(mem_addr, s.st_size);

	return 0;
}


char *kv_store_read(const char *key){

	//Input validation
	if (key == NULL){
		printf("Please enter a valid key...\n");
		return 0;
	}

	//Open shared memory slot
	int fd = shm_open(db_name, O_RDWR, S_IRWXU);
	//If unsuccessful, prevent the caller
	if (fd == -1){
		printf("Could not open shared memory\n");
		return 0;
	}

	//Get size of the shared memory
	struct stat s;
	if(fstat(fd, &s) == -1){
		printf("Could not determine length of the shared memory\n");
		return 0;
	}

#ifdef DEBUG
	printf("Size of memory shared(read): %d\n", (int)s.st_size);
#endif

	//Map this new memory address to a base address generated by the os
	char *mem_addr = mmap(NULL, s.st_size, PROT_READ, MAP_SHARED, fd, 0);
	close(fd);

	//Reproduce key and make sure it is right size
	char normalizedKey[KEY_MAX_LENGTH];
	strncpy(normalizedKey, key, KEY_MAX_LENGTH);
	normalizedKey[KEY_MAX_LENGTH-1] = '\0';

	//Show new result if truncated
	if (strlen(key) > KEY_MAX_LENGTH-1){
		printf("Key too big, Truncated key is: %s\n", normalizedKey);
	}

	//Reconstruct the element from the hashmap using the key
	int hashkey = hash_func(normalizedKey);

	//Create a pod index to limit the number of searches in the end for large number of elements in a pod
	int pod_index[POD_NUMBER_LIMIT];
	memcpy(pod_index, mem_addr + sizeof(struct node) * POD_SIZE * POD_NUMBER_LIMIT, sizeof(pod_index));


	//If the size the pod is 0 then the key does not exist
	if(pod_index[hashkey] == 0){
		return 0;
	}

	/*
	struct node *new_node = malloc(sizeof(struct node));
	printf("test\n");
	memcpy(new_node, mem_addr + hashkey*POD_SIZE + 0*sizeof(struct node), sizeof(struct node));

	printf("%s\n", new_node->value);

	memcpy(new_node, mem_addr + hashkey*POD_SIZE + 1*sizeof(struct node), sizeof(struct node));

	printf("%s\n", new_node->value);

	memcpy(new_node, mem_addr + hashkey*POD_SIZE + 2*sizeof(struct node), sizeof(struct node));

	printf("%s\n", new_node->value);

	printf("test\n");
	 */

	//Find the index of the correct value to read (FIFO). If no value from that key was yet read, take the first one encountered
	//When we hit a -1, all the values after that are uninitialized so don't need to traverse the whole array
	int i;
	for (i = 0; i < READ_CYCLING_MAX; i++){
		if (read_array[i]->index == -1) {
			strcpy(read_array[i]->key, normalizedKey);
			read_array[i]->index = 0;
			break;
		}

		if(!strcmp(read_array[i]->key, normalizedKey)){

			read_array[i]->index++;
			break;
		}
	}

	//Count each corresponding key until the count is equal to the index we previously created
	struct node *new_node = malloc(sizeof(struct node));
	int count = 0;
	for(int j = 0; j < pod_index[hashkey]; j++){
		memcpy(new_node, mem_addr + hashkey*POD_SIZE + j*sizeof(struct node), sizeof(struct node));
		if(!strcmp(new_node->key, normalizedKey)){
			if(count == read_array[i]->index){
				break;
			}
			count++;
		}

		//If we got to then end of the array, therefore we have to go back to beginning and pick the first read value
		if(j == pod_index[hashkey]-1){
			//Avoid infinite loop if value not found
			if(count == 0) break;
			j = -1;
			count = 0;
			read_array[i]->index = 0;
		}
	}

	munmap(mem_addr, s.st_size);

	//If we did not find the right key, return nothing found
	if(strcmp(new_node->key, normalizedKey)){
		free(new_node);
		return 0;
	}

	//Copy the value to a new char array to free that variable in the caller
	char *value = strdup(new_node->value);
	free(new_node);

	return value;
}


char **kv_store_read_all(const char *key){

	return 0;
}
